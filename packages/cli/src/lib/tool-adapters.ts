import { writeFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join, dirname } from "node:path";
import chalk from "chalk";
import { MARKER, makeFooter, hasOurMarker } from "./markers.js";
import { success as uiSuccess, warn as uiWarn, error as uiError } from "./ui.js";
import {
  type AdaptResult,
  type FlatFileOptions,
  emptyResult,
  safeRead,
  listMdFiles,
  listSkillDirs,
  safeWrite,
  mergeSettings,
  stripFrontmatter,
  extractPaths,
} from "./tool-adapters-helpers.js";

// Re-export for backward compatibility
export type { AdaptResult, FlatFileOptions } from "./tool-adapters-helpers.js";

// ── 4a: Claude Code Adapter ─────────────────────────────────────────

async function adaptForClaude(
  agentsDir: string,
  outputDir: string,
): Promise<AdaptResult> {
  const result = emptyResult();

  // 1. instructions.md → CLAUDE.md
  try {
    const instructions = await safeRead(join(agentsDir, "instructions.md"));
    if (instructions) {
      const content = `# Project Memories\n\n${instructions}${makeFooter()}`;
      await safeWrite(join(outputDir, "CLAUDE.md"), content, result);
    }
  } catch (error) {
    result.errors.push(`instructions.md: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  // 2. rules/*.md → .claude/rules/*.md
  try {
    const ruleFiles = await listMdFiles(join(agentsDir, "rules"));
    for (const file of ruleFiles) {
      const content = await safeRead(join(agentsDir, "rules", file));
      if (!content) continue;

      const out = content.includes(MARKER) ? content : content + makeFooter();
      await safeWrite(join(outputDir, ".claude", "rules", file), out, result);
    }
  } catch (error) {
    result.errors.push(`rules: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  // 3. skills/**/SKILL.md → .claude/skills/**/SKILL.md
  try {
    const skillDirs = await listSkillDirs(join(agentsDir, "skills"));
    for (const dir of skillDirs) {
      const content = await safeRead(join(agentsDir, "skills", dir, "SKILL.md"));
      if (!content) continue;

      const out = content.includes(MARKER) ? content : content + makeFooter();
      await safeWrite(join(outputDir, ".claude", "skills", dir, "SKILL.md"), out, result);
    }
  } catch (error) {
    result.errors.push(`skills: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  // 4. settings.json → .claude/settings.json (merge)
  try {
    const incomingRaw = await safeRead(join(agentsDir, "settings.json"));
    if (incomingRaw) {
      const incoming = JSON.parse(incomingRaw) as Record<string, unknown>;
      const existingPath = join(outputDir, ".claude", "settings.json");
      const existingRaw = await safeRead(existingPath);

      if (existingRaw) {
        const existing = JSON.parse(existingRaw) as Record<string, unknown>;
        const merged = mergeSettings(existing, incoming);
        await mkdir(join(outputDir, ".claude"), { recursive: true });
        await writeFile(existingPath, JSON.stringify(merged, null, 2) + "\n", "utf-8");
        result.filesCreated.push(existingPath);
      } else {
        await safeWrite(existingPath, JSON.stringify(incoming, null, 2) + "\n", result, true);
      }
    }
  } catch (error) {
    result.errors.push(`settings.json: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  return result;
}

// ── 4b: Cursor Adapter ──────────────────────────────────────────────

async function adaptForCursor(
  agentsDir: string,
  outputDir: string,
): Promise<AdaptResult> {
  const result = emptyResult();

  // 1. instructions.md → .cursor/rules/memories.mdc
  try {
    const instructions = await safeRead(join(agentsDir, "instructions.md"));
    if (instructions) {
      const body = instructions.replace(/\n<!-- Generated by memories\.sh at .+? -->/, "");
      const frontmatter = [
        "---",
        "description: Project memories and rules from memories.sh",
        "globs:",
        "alwaysApply: true",
        "---",
      ].join("\n");
      const content = `${frontmatter}\n\n# Project Memories\n\n${body.trim()}${makeFooter()}`;
      await safeWrite(join(outputDir, ".cursor", "rules", "memories.mdc"), content, result);
    }
  } catch (error) {
    result.errors.push(`instructions.md: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  // 2. rules/*.md → .cursor/rules/{name}.mdc
  try {
    const ruleFiles = await listMdFiles(join(agentsDir, "rules"));
    for (const file of ruleFiles) {
      const content = await safeRead(join(agentsDir, "rules", file));
      if (!content) continue;

      const { frontmatter, body } = stripFrontmatter(content);
      const paths = extractPaths(frontmatter);

      const globs = paths.length > 0 ? paths.join(",") : "";
      const description = paths.length > 0
        ? `Rules for ${paths.join(", ")}`
        : `Rules from ${file}`;

      const mdcFrontmatter = [
        "---",
        `description: ${description}`,
        ...(globs ? [`globs: ${globs}`] : ["globs:"]),
        `alwaysApply: ${paths.length === 0}`,
        "---",
      ].join("\n");

      const cleanBody = body.replace(/\n<!-- Generated by memories\.sh at .+? -->/, "").trim();
      const mdcName = file.replace(/\.md$/, ".mdc");
      const out = `${mdcFrontmatter}\n\n${cleanBody}${makeFooter()}`;
      await safeWrite(join(outputDir, ".cursor", "rules", mdcName), out, result);
    }
  } catch (error) {
    result.errors.push(`rules: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  // 3. skills/**/SKILL.md → .cursor/skills/**/SKILL.md
  try {
    const skillDirs = await listSkillDirs(join(agentsDir, "skills"));
    for (const dir of skillDirs) {
      const content = await safeRead(join(agentsDir, "skills", dir, "SKILL.md"));
      if (!content) continue;

      const out = content.includes(MARKER) ? content : content + makeFooter();
      await safeWrite(join(outputDir, ".cursor", "skills", dir, "SKILL.md"), out, result);
    }
  } catch (error) {
    result.errors.push(`skills: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  return result;
}

// ── 4c: Flat-File Adapter ───────────────────────────────────────────

async function adaptForFlatFile(
  agentsDir: string,
  outputPath: string,
  options?: FlatFileOptions,
): Promise<AdaptResult> {
  const result = emptyResult();
  const header = options?.header ?? "# Project Memories";
  const maxLength = options?.maxLength;

  try {
    const sections: string[] = [];

    const instructions = await safeRead(join(agentsDir, "instructions.md"));
    if (instructions) {
      const clean = instructions.replace(/\n<!-- Generated by memories\.sh at .+? -->/, "").trim();
      if (clean) sections.push(clean);
    }

    const ruleFiles = await listMdFiles(join(agentsDir, "rules"));
    for (const file of ruleFiles) {
      const content = await safeRead(join(agentsDir, "rules", file));
      if (!content) continue;

      const { frontmatter, body } = stripFrontmatter(content);
      const paths = extractPaths(frontmatter);
      const cleanBody = body.replace(/\n<!-- Generated by memories\.sh at .+? -->/, "").trim();

      if (cleanBody) {
        if (paths.length > 0) {
          sections.push(`### Rules for ${paths.join(", ")}\n\n${cleanBody}`);
        } else {
          sections.push(cleanBody);
        }
      }
    }

    if (sections.length === 0) {
      return result;
    }

    let content = `${header}\n\n${sections.join("\n\n")}`;

    if (maxLength && content.length > maxLength) {
      const truncated = content.slice(0, maxLength);
      const lastNewline = truncated.lastIndexOf("\n");
      content = lastNewline > 0
        ? truncated.slice(0, lastNewline) + "\n\n> _Truncated to fit character limit._"
        : truncated;
    }

    content += makeFooter();

    if (existsSync(outputPath)) {
      const ours = await hasOurMarker(outputPath);
      if (!ours) {
        result.filesSkipped.push(outputPath);
        return result;
      }
    }

    await mkdir(join(outputPath, ".."), { recursive: true });
    await writeFile(outputPath, content, "utf-8");
    result.filesCreated.push(outputPath);
  } catch (error) {
    result.errors.push(`flat-file: ${error instanceof Error ? error.message : "Unknown error"}`);
  }

  return result;
}

// ── Adapter Dispatch ─────────────────────────────────────────────────

/** Target names that have adapter support. */
export const ADAPTER_TARGETS = new Set([
  "claude", "cursor", "copilot", "windsurf", "cline", "roo", "gemini",
]);

/**
 * Run the appropriate adapter for a target name.
 * Returns null if no adapter exists for the given target.
 */
export async function runAdapter(
  targetName: string,
  agentsDir: string,
  outputDir: string,
): Promise<AdaptResult | null> {
  switch (targetName) {
    case "claude": return adaptForClaude(agentsDir, outputDir);
    case "cursor": return adaptForCursor(agentsDir, outputDir);
    case "copilot": return adaptForFlatFile(agentsDir, join(outputDir, ".github", "copilot-instructions.md"));
    case "windsurf": return adaptForFlatFile(agentsDir, join(outputDir, ".windsurf", "rules", "memories.md"), { maxLength: 6000 });
    case "cline": return adaptForFlatFile(agentsDir, join(outputDir, ".clinerules", "memories.md"));
    case "roo": return adaptForFlatFile(agentsDir, join(outputDir, ".roo", "rules", "memories.md"));
    case "gemini": return adaptForFlatFile(agentsDir, join(outputDir, "GEMINI.md"));
    default: return null;
  }
}

// ── Reporting ────────────────────────────────────────────────────────

/**
 * Log the result of an adapter run to the console.
 */
export function logAdaptResult(targetName: string, result: AdaptResult): void {
  for (const file of result.filesCreated) {
    uiSuccess(`Wrote ${targetName} → ${chalk.dim(file)}`);
  }
  for (const file of result.filesSkipped) {
    uiWarn(`Skipped ${chalk.dim(file)} (not generated by memories.sh, use --force)`);
  }
  for (const err of result.errors) {
    uiError(`${targetName} adapter error: ${err}`);
  }
}
