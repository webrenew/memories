import { Command } from "commander";
import chalk from "chalk";
import { readFile } from "node:fs/promises";
import * as ui from "../lib/ui.js";
import { existsSync } from "node:fs";
import { resolve } from "node:path";
import { listMemories, isMemoryType, MEMORY_TYPES, type Memory, type MemoryType } from "../lib/memory.js";
import { getProjectId } from "../lib/git.js";

import { MARKER } from "../lib/markers.js";

interface Target {
  name: string;
  defaultPath: string;
}

const TARGETS: Target[] = [
  { name: "cursor", defaultPath: ".cursor/rules/memories.mdc" },
  { name: "claude", defaultPath: "CLAUDE.md" },
  { name: "agents", defaultPath: ".agents/instructions.md" },
  { name: "copilot", defaultPath: ".github/copilot-instructions.md" },
  { name: "windsurf", defaultPath: ".windsurf/rules/memories.md" },
  { name: "cline", defaultPath: ".clinerules/memories.md" },
  { name: "roo", defaultPath: ".roo/rules/memories.md" },
  { name: "gemini", defaultPath: "GEMINI.md" },
];

/**
 * Extract memory content lines from a generated file.
 * Looks for lines starting with "- " under ## headings.
 */
function extractFileMemories(content: string): Set<string> {
  const memories = new Set<string>();
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed.startsWith("- ") && trimmed.length > 2) {
      memories.add(trimmed.slice(2));
    }
  }
  return memories;
}

/**
 * Extract the generation timestamp from the footer marker.
 */
function extractTimestamp(content: string): string | null {
  const match = content.match(/Generated by memories\.sh at (.+?)\s*-->/);
  return match ? match[1] : null;
}

function parseTypes(raw: string | undefined): MemoryType[] {
  if (!raw) return ["rule", "decision", "fact"];
  const parts = raw.split(",").map((s) => s.trim());
  for (const t of parts) {
    if (!isMemoryType(t)) {
      ui.error(`Invalid type "${t}". Valid: ${MEMORY_TYPES.join(", ")}`);
      process.exit(1);
    }
  }
  return parts.filter(isMemoryType);
}

async function fetchMemories(types: MemoryType[]): Promise<Memory[]> {
  const projectId = getProjectId() ?? undefined;
  return listMemories({ limit: 10000, types, projectId });
}

async function diffTarget(
  target: Target,
  currentMemories: Memory[],
  outputPath?: string,
): Promise<{ added: string[]; removed: string[]; unchanged: number; filePath: string; exists: boolean; isOurs: boolean; generatedAt: string | null }> {
  const filePath = resolve(outputPath ?? target.defaultPath);

  if (!existsSync(filePath)) {
    return {
      added: currentMemories.map((m) => m.content),
      removed: [],
      unchanged: 0,
      filePath,
      exists: false,
      isOurs: false,
      generatedAt: null,
    };
  }

  const content = await readFile(filePath, "utf-8");
  const isOurs = content.includes(MARKER);
  const generatedAt = extractTimestamp(content);
  const fileMemories = extractFileMemories(content);
  const currentSet = new Set(currentMemories.map((m) => m.content));

  const added = [...currentSet].filter((c) => !fileMemories.has(c));
  const removed = [...fileMemories].filter((c) => !currentSet.has(c));
  const unchanged = [...currentSet].filter((c) => fileMemories.has(c)).length;

  return { added, removed, unchanged, filePath, exists: true, isOurs, generatedAt };
}

export const diffCommand = new Command("diff")
  .description("Show what changed since last generate (are IDE rule files stale?)")
  .argument("[target]", `Target to check (${TARGETS.map((t) => t.name).join(", ")}, or all)`)
  .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
  .action(async (target: string | undefined, opts: { types?: string }) => {
    try {
      const types = parseTypes(opts.types);
      const memories = await fetchMemories(types);

      const targetsToCheck = target && target !== "all"
        ? TARGETS.filter((t) => t.name === target)
        : TARGETS;

      if (target && target !== "all" && targetsToCheck.length === 0) {
        ui.error(`Unknown target "${target}". Valid: ${TARGETS.map((t) => t.name).join(", ")}`);
        process.exit(1);
      }

      let anyStale = false;

      for (const t of targetsToCheck) {
        const result = await diffTarget(t, memories);

        // Skip targets that don't exist and weren't requested specifically
        if (!result.exists && !target) continue;

        const hasChanges = result.added.length > 0 || result.removed.length > 0;

        if (!result.exists) {
          console.log(chalk.bold(`\n  ${t.name}`) + chalk.dim(` → ${result.filePath}`));
          console.log(chalk.yellow("    Not generated yet.") + chalk.dim(` Run: memories generate ${t.name}`));
          anyStale = true;
          continue;
        }

        if (!result.isOurs) {
          console.log(chalk.bold(`\n  ${t.name}`) + chalk.dim(` → ${result.filePath}`));
          console.log(chalk.dim("    Not managed by memories.sh (no marker found)"));
          continue;
        }

        if (!hasChanges) {
          if (target) {
            // Only show up-to-date message when specifically requested
            console.log(chalk.bold(`\n  ${t.name}`) + chalk.dim(` → ${result.filePath}`));
            const since = result.generatedAt ? chalk.dim(` (generated ${formatRelative(result.generatedAt)})`) : "";
            console.log(chalk.green("    Up to date.") + since);
          }
          continue;
        }

        anyStale = true;
        console.log(chalk.bold(`\n  ${t.name}`) + chalk.dim(` → ${result.filePath}`));
        if (result.generatedAt) {
          console.log(chalk.dim(`    Generated ${formatRelative(result.generatedAt)}`));
        }

        for (const a of result.added) {
          console.log(chalk.green(`    + ${a}`));
        }
        for (const r of result.removed) {
          console.log(chalk.red(`    - ${r}`));
        }
        if (result.unchanged > 0) {
          console.log(chalk.dim(`    ${result.unchanged} unchanged`));
        }
      }

      if (!anyStale) {
        if (target) {
          // Already printed per-target status
        } else {
          console.log(chalk.green("\n  All generated files are up to date."));
        }
      } else {
        console.log(chalk.dim(`\n  Run ${chalk.bold("memories generate")} to update stale files.`));
      }
    } catch (error) {
      ui.error("Diff failed: " + (error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });

function formatRelative(isoDate: string): string {
  const then = new Date(isoDate);
  const now = new Date();
  const diffMs = now.getTime() - then.getTime();

  if (diffMs < 0) return "just now";

  const seconds = Math.floor(diffMs / 1000);
  if (seconds < 60) return "just now";

  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;

  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;

  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}
