import { Command } from "commander";
import chalk from "chalk";
import { writeFile, readFile, mkdir } from "node:fs/promises";
import * as ui from "../lib/ui.js";
import { existsSync, watch as fsWatch } from "node:fs";
import { dirname, resolve, join, relative } from "node:path";
import { getDataDir } from "../lib/env.js";
import { checkbox } from "@inquirer/prompts";
import { listMemories, isMemoryType, MEMORY_TYPES, type Memory, type MemoryType } from "../lib/memory.js";
import { getProjectId } from "../lib/git.js";
import { generateAgentsDir } from "../lib/agents-generator.js";
import {
  ADAPTER_TARGETS,
  runAdapter,
  logAdaptResult,
} from "../lib/tool-adapters.js";
import { formatMemoriesAsMarkdown, formatCursorMdc, formatWindsurf } from "../lib/formatters.js";
import { MARKER, makeFooter, hasOurMarker } from "../lib/markers.js";

// ── Target Registry ─────────────────────────────────────────────────

interface Target {
  name: string;
  defaultPath: string;
  description: string;
  format: (memories: Memory[]) => string;
}

const TARGETS: Target[] = [
  {
    name: "cursor",
    defaultPath: ".cursor/rules/memories.mdc",
    description: "Cursor rules file (.cursor/rules/memories.mdc)",
    format: formatCursorMdc,
  },
  {
    name: "claude",
    defaultPath: "CLAUDE.md",
    description: "Claude Code instructions (CLAUDE.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "agents",
    defaultPath: ".agents/",
    description: ".agents/ directory (instructions, rules, skills, settings)",
    // format is unused for agents — handled by generateAgentsDir
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "copilot",
    defaultPath: ".github/copilot-instructions.md",
    description: "GitHub Copilot instructions (.github/copilot-instructions.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "windsurf",
    defaultPath: ".windsurf/rules/memories.md",
    description: "Windsurf rules (.windsurf/rules/memories.md)",
    format: formatWindsurf,
  },
  {
    name: "cline",
    defaultPath: ".clinerules/memories.md",
    description: "Cline rules (.clinerules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "roo",
    defaultPath: ".roo/rules/memories.md",
    description: "Roo rules (.roo/rules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "gemini",
    defaultPath: "GEMINI.md",
    description: "Gemini instructions (GEMINI.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
];

// ── .gitignore Management ───────────────────────────────────────────

// Files users likely want git-tracked (shared with team)
const TRACK_BY_DEFAULT = new Set(["CLAUDE.md", ".agents/", "GEMINI.md", ".github/copilot-instructions.md"]);

async function checkGitignore(filePath: string): Promise<void> {
  // Only suggest for files in hidden directories (tool-specific)
  if (TRACK_BY_DEFAULT.has(filePath)) return;

  const gitignorePath = resolve(".gitignore");
  try {
    const content = existsSync(gitignorePath)
      ? await readFile(gitignorePath, "utf-8")
      : "";

    // Check if already ignored (exact line match or parent dir match)
    const lines = content.split("\n");
    const parentDir = filePath.split("/")[0]; // e.g. ".cursor"
    if (lines.some((l) => l.trim() === filePath || l.trim() === parentDir || l.trim() === `${parentDir}/`)) {
      return;
    }

    console.log(chalk.dim(`  hint: add "${filePath}" to .gitignore if you don't want it tracked`));
  } catch {
    // Ignore errors reading .gitignore
  }
}

async function writeTarget(
  target: Target,
  memories: Memory[],
  opts: { output?: string; dryRun?: boolean; force?: boolean },
): Promise<void> {
  const outPath = resolve(opts.output ?? target.defaultPath);
  const content = target.format(memories) + makeFooter();

  if (opts.dryRun) {
    console.log(chalk.dim(`── ${target.name} → ${outPath} ──`));
    console.log(content);
    console.log();
    return;
  }

  // Overwrite safety
  if (existsSync(outPath)) {
    const ours = await hasOurMarker(outPath);
    if (!ours && !opts.force) {
      ui.warn(`${outPath} exists and was not generated by memories.sh. Use ${chalk.bold("--force")} to overwrite.`);
      return;
    }
  }

  await mkdir(dirname(outPath), { recursive: true });
  await writeFile(outPath, content, "utf-8");
  ui.success(`Wrote ${target.name} → ${chalk.dim(outPath)}`);

  // Suggest .gitignore for tool-specific hidden dirs
  await checkGitignore(opts.output ?? target.defaultPath);
}

// ── Agents Directory Generator ───────────────────────────────────────

async function runAgentsGenerator(opts: { dryRun?: boolean }): Promise<void> {
  if (opts.dryRun) {
    console.log(chalk.dim("── agents → .agents/ (dry-run) ──"));
    console.log(chalk.dim("Would generate: instructions.md, rules/*.md, skills/**/SKILL.md, settings.json"));
    return;
  }

  const result = await generateAgentsDir(process.cwd());

  for (const file of result.filesCreated) {
    ui.success(`Wrote agents → ${chalk.dim(file)}`);
  }
  for (const file of result.filesCleaned) {
    console.log(chalk.yellow("✓") + ` Cleaned stale → ${chalk.dim(file)}`);
  }

  const parts: string[] = [];
  if (result.counts.instructions > 0) parts.push(`${result.counts.instructions} instructions`);
  if (result.counts.rules > 0) parts.push(`${result.counts.rules} rule files`);
  if (result.counts.skills > 0) parts.push(`${result.counts.skills} skills`);
  if (result.counts.settings) parts.push("settings.json");
  if (parts.length > 0) {
    console.log(chalk.dim(`  (${parts.join(", ")})`));
  } else {
    console.log(chalk.dim("  (harness baseline only)"));
  }
}

// ── Two-Step Pipeline ────────────────────────────────────────────────

/**
 * Run the adapter for a target, reading from .agents/.
 * Expects .agents/ to already be populated. Falls back to legacy writeTarget
 * if .agents/ doesn't exist or the adapter produces no output.
 */
async function runAdapterOrFallback(
  targetName: string,
  memories: Memory[],
  target: Target,
  opts: { output?: string; dryRun?: boolean; force?: boolean },
): Promise<void> {
  if (opts.dryRun) {
    console.log(chalk.dim(`── ${targetName} → .agents/ adapter (dry-run) ──`));
    return;
  }

  const cwd = process.cwd();
  const agentsDir = join(cwd, ".agents");

  if (!existsSync(agentsDir)) {
    await writeTarget(target, memories, opts);
    return;
  }

  const adaptResult = await runAdapter(targetName, agentsDir, cwd);
  if (!adaptResult || (adaptResult.filesCreated.length === 0 && adaptResult.errors.length === 0)) {
    await writeTarget(target, memories, opts);
    return;
  }

  logAdaptResult(targetName, adaptResult);
  for (const file of adaptResult.filesCreated) {
    await checkGitignore(relative(cwd, file));
  }
}

// ── Fetch Memories ──────────────────────────────────────────────────

async function fetchMemories(types: MemoryType[]): Promise<Memory[]> {
  const projectId = getProjectId() ?? undefined;
  return listMemories({
    limit: 10000,
    types,
    projectId,
  });
}

function parseTypes(raw: string | undefined): MemoryType[] {
  if (!raw) return ["rule", "decision", "fact"];
  const parts = raw.split(",").map((s) => s.trim());
  for (const t of parts) {
    if (!isMemoryType(t)) {
      ui.error(`Invalid type "${t}". Valid: ${MEMORY_TYPES.join(", ")}`);
      process.exit(1);
    }
  }
  return parts.filter(isMemoryType);
}

// ── Watch Mode ──────────────────────────────────────────────────────

function getDbPath(): string {
  return join(getDataDir(), "local.db");
}

/**
 * Run a full generation cycle: .agents/ first, then adapters for each target, legacy fallback for the rest.
 */
async function runGenerationCycle(
  targets: Target[],
  memories: Memory[],
  opts: { force?: boolean },
): Promise<void> {
  const cwd = process.cwd();

  // Step 1: Generate .agents/ once
  try {
    await generateAgentsDir(cwd);
  } catch (error) {
    ui.error("Failed to generate .agents/: " + (error instanceof Error ? error.message : "Unknown error"));
  }

  // Step 2: Run adapters or legacy fallback per target
  for (const target of targets) {
    if (target.name === "agents") continue; // Already handled above
    if (ADAPTER_TARGETS.has(target.name)) {
      await runAdapterOrFallback(target.name, memories, target, { force: opts.force ?? true });
    } else {
      await writeTarget(target, memories, { force: opts.force ?? true });
    }
  }
}

async function runWatch(
  targets: Target[],
  memories: () => Promise<Memory[]>,
  opts: { force?: boolean },
): Promise<void> {
  const dbPath = getDbPath();
  if (!existsSync(dbPath)) {
    ui.error("Database not found. Run: memories init");
    process.exit(1);
  }

  console.log(chalk.dim(`Watching ${dbPath} for changes... (Ctrl+C to stop)\n`));

  // Initial generate using two-step pipeline
  const mems = await memories();
  await runGenerationCycle(targets, mems, opts);

  // Watch for DB changes with debounce
  let timeout: ReturnType<typeof setTimeout> | null = null;
  fsWatch(dbPath, () => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(async () => {
      try {
        const mems = await memories();
        await runGenerationCycle(targets, mems, opts);
      } catch (err) {
        ui.error("Watch error: " + (err instanceof Error ? err.message : "Unknown error"));
      }
    }, 500);
  });

  // Keep process alive
  await new Promise(() => {});
}

// ── Command ─────────────────────────────────────────────────────────

export const generateCommand = new Command("generate")
  .description("Generate IDE rule/instruction files from memories")
  .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
  .option("--dry-run", "Preview without writing")
  .option("--force", "Overwrite files not generated by memories.sh")
  .option("-w, --watch", "Watch for memory changes and auto-regenerate")
  .action(async (opts: { types?: string; dryRun?: boolean; force?: boolean; watch?: boolean }) => {
    try {
      // Interactive mode: prompt user to pick targets
      if (!process.stdin.isTTY) {
        generateCommand.outputHelp();
        return;
      }

      const selected = await checkbox({
        message: "Select targets to generate",
        choices: TARGETS.map((t) => ({
          name: `${t.name} ${chalk.dim(`→ ${t.defaultPath}`)}`,
          value: t.name,
          checked: true,
        })),
      });

      if (selected.length === 0) {
        console.log(chalk.dim("No targets selected."));
        return;
      }

      const types = parseTypes(opts.types);
      const memories = await fetchMemories(types);
      if (memories.length === 0) {
        console.log(chalk.dim("No stored memories found. Generating harness/baseline files."));
      }

      const selectedSet = new Set(selected);

      // Generate .agents/ once if any target needs it (agents target or adapter targets)
      const needsAgents = selectedSet.has("agents") || [...selectedSet].some((n) => ADAPTER_TARGETS.has(n));
      if (needsAgents) {
        await runAgentsGenerator(opts);
        selectedSet.delete("agents");
      }

      // Two-step pipeline: .agents/ → adapter for supported targets
      const adapterTargets = [...selectedSet].filter((n) => ADAPTER_TARGETS.has(n));
      for (const name of adapterTargets) {
        const target = TARGETS.find((t) => t.name === name);
        if (target) {
          await runAdapterOrFallback(name, memories, target, opts);
          selectedSet.delete(name);
        }
      }

      // Legacy fallback for any remaining targets
      for (const target of TARGETS.filter((t) => selectedSet.has(t.name))) {
        await writeTarget(target, memories, opts);
      }

      if (opts.watch) {
        await runWatch(TARGETS, () => fetchMemories(types), opts);
      }
    } catch (error) {
      if (error instanceof Error && error.name === "ExitPromptError") return;
      ui.error("Failed to generate: " + (error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });

// Register a subcommand for each target
for (const target of TARGETS) {
  if (target.name === "agents") {
    // agents subcommand uses the directory generator
    generateCommand.addCommand(
      new Command("agents")
        .description(target.description)
        .option("--dry-run", "Preview without writing")
        .action(async (opts: { dryRun?: boolean }) => {
          try {
            await runAgentsGenerator(opts);
          } catch (error) {
            ui.error("Failed to generate .agents/: " + (error instanceof Error ? error.message : "Unknown error"));
            process.exit(1);
          }
        }),
    );
    continue;
  }

  generateCommand.addCommand(
    new Command(target.name)
      .description(target.description)
      .option("-o, --output <path>", "Override output path")
      .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
      .option("--dry-run", "Preview without writing")
      .option("--force", "Overwrite files not generated by memories.sh")
      .action(async (opts: { output?: string; types?: string; dryRun?: boolean; force?: boolean }) => {
        try {
          const types = parseTypes(opts.types);
          const memories = await fetchMemories(types);
          if (memories.length === 0) {
            console.log(chalk.dim("No stored memories found. Generating harness/baseline files."));
          }

          // Use two-step pipeline for adapter-supported targets (skip if custom output path)
          if (ADAPTER_TARGETS.has(target.name) && !opts.output) {
            await generateAgentsDir(process.cwd());
            await runAdapterOrFallback(target.name, memories, target, opts);
          } else {
            await writeTarget(target, memories, opts);
          }
        } catch (error) {
          ui.error(`Failed to generate ${target.name}: ` + (error instanceof Error ? error.message : "Unknown error"));
          process.exit(1);
        }
      }),
  );
}

// "all" subcommand
generateCommand.addCommand(
  new Command("all")
    .description("Generate rule files for all supported targets")
    .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
    .option("--dry-run", "Preview without writing")
    .option("--force", "Overwrite files not generated by memories.sh")
    .option("-w, --watch", "Watch for memory changes and auto-regenerate")
    .action(async (opts: { types?: string; dryRun?: boolean; force?: boolean; watch?: boolean }) => {
      try {
        const types = parseTypes(opts.types);

        if (opts.watch) {
          await runWatch(TARGETS, () => fetchMemories(types), opts);
          return;
        }

        const memories = await fetchMemories(types);
        if (memories.length === 0) {
          console.log(chalk.dim("No stored memories found. Generating harness/baseline files."));
        }

        // Step 1: Generate .agents/ directory once
        await runAgentsGenerator(opts);

        // Step 2: Run adapters for each target
        for (const target of TARGETS) {
          if (target.name === "agents") continue; // Already done above

          if (ADAPTER_TARGETS.has(target.name)) {
            await runAdapterOrFallback(target.name, memories, target, opts);
          } else {
            await writeTarget(target, memories, opts);
          }
        }
      } catch (error) {
        ui.error("Failed to generate: " + (error instanceof Error ? error.message : "Unknown error"));
        process.exit(1);
      }
    }),
);
