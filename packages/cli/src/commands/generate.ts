import { Command } from "commander";
import chalk from "chalk";
import { writeFile, readFile, mkdir } from "node:fs/promises";
import { existsSync, watch as fsWatch } from "node:fs";
import { dirname, resolve, join } from "node:path";
import { homedir } from "node:os";
import { checkbox } from "@inquirer/prompts";
import { listMemories, type Memory, type MemoryType } from "../lib/memory.js";
import { getProjectId } from "../lib/git.js";

const MARKER = "Generated by memories.sh";
const VALID_TYPES: MemoryType[] = ["rule", "decision", "fact", "note"];

// ── Formatters ──────────────────────────────────────────────────────

function groupByType(memories: Memory[]): { title: string; memories: Memory[] }[] {
  const groups: Record<string, Memory[]> = {};
  for (const m of memories) {
    const title =
      m.type === "rule" ? "Rules" :
      m.type === "decision" ? "Key Decisions" :
      m.type === "fact" ? "Project Facts" :
      "Notes";
    (groups[title] ??= []).push(m);
  }
  // Stable order: Rules → Key Decisions → Project Facts → Notes
  const order = ["Rules", "Key Decisions", "Project Facts", "Notes"];
  return order
    .filter((t) => groups[t]?.length)
    .map((title) => ({ title, memories: groups[title] }));
}

const AGENT_INSTRUCTIONS = `## Memory Management

When you learn something important about this project, save it for future sessions.

**Via CLI:**
- \`memories add "<decision>" --type decision\` — Architectural decisions
- \`memories add "<convention>" --type rule\` — Coding conventions
- \`memories add "<fact>" --type fact\` — Project facts

**Via MCP (if connected):**
Use the \`add_memory\` tool with content and type parameters.

**When to save:**
- Architectural decisions and their rationale
- Project-specific patterns or conventions
- Non-obvious setup, configuration, or gotchas
- Tricky bugs and how they were resolved`;

function formatMemoriesAsMarkdown(memories: Memory[], includeAgentInstructions = true): string {
  const sections = groupByType(memories);
  const memoriesContent = sections.length === 0 ? "" : sections
    .map(({ title, memories: mems }) => {
      const items = mems.map((m) => `- ${m.content}`).join("\n");
      return `## ${title}\n\n${items}`;
    })
    .join("\n\n");
  
  if (includeAgentInstructions) {
    return memoriesContent ? `${memoriesContent}\n\n${AGENT_INSTRUCTIONS}` : AGENT_INSTRUCTIONS;
  }
  return memoriesContent;
}

function formatCursorMdc(memories: Memory[]): string {
  const body = formatMemoriesAsMarkdown(memories, true);
  const frontmatter = [
    "---",
    "description: Project memories and rules from memories.sh",
    "globs:",
    "alwaysApply: true",
    "---",
  ].join("\n");
  return `${frontmatter}\n\n# Project Memories\n\n${body}`;
}

function formatWindsurf(memories: Memory[]): string {
  const full = formatMemoriesAsMarkdown(memories, true);
  const LIMIT = 6000;
  if (full.length <= LIMIT) return full;
  // Truncate on a line boundary
  const truncated = full.slice(0, LIMIT);
  const lastNewline = truncated.lastIndexOf("\n");
  return lastNewline > 0
    ? truncated.slice(0, lastNewline) + "\n\n> _Truncated to fit Windsurf 6000 char limit._"
    : truncated;
}

// ── Target Registry ─────────────────────────────────────────────────

interface Target {
  name: string;
  defaultPath: string;
  description: string;
  format: (memories: Memory[]) => string;
}

const TARGETS: Target[] = [
  {
    name: "cursor",
    defaultPath: ".cursor/rules/memories.mdc",
    description: "Cursor rules file (.cursor/rules/memories.mdc)",
    format: formatCursorMdc,
  },
  {
    name: "claude",
    defaultPath: "CLAUDE.md",
    description: "Claude Code instructions (CLAUDE.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "agents",
    defaultPath: "AGENTS.md",
    description: "AGENTS.md for Amp, Codex, Goose, Kilo, Kiro, OpenCode",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "copilot",
    defaultPath: ".github/copilot-instructions.md",
    description: "GitHub Copilot instructions (.github/copilot-instructions.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "windsurf",
    defaultPath: ".windsurf/rules/memories.md",
    description: "Windsurf rules (.windsurf/rules/memories.md)",
    format: formatWindsurf,
  },
  {
    name: "cline",
    defaultPath: ".clinerules/memories.md",
    description: "Cline rules (.clinerules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "roo",
    defaultPath: ".roo/rules/memories.md",
    description: "Roo rules (.roo/rules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "gemini",
    defaultPath: "GEMINI.md",
    description: "Gemini instructions (GEMINI.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
];

// ── Shared Write Logic ──────────────────────────────────────────────

function makeFooter(): string {
  return `\n\n<!-- ${MARKER} at ${new Date().toISOString()} -->`;
}

async function hasOurMarker(filePath: string): Promise<boolean> {
  try {
    const content = await readFile(filePath, "utf-8");
    return content.includes(MARKER);
  } catch {
    return false;
  }
}

// ── .gitignore Management ───────────────────────────────────────────

// Files users likely want git-tracked (shared with team)
const TRACK_BY_DEFAULT = new Set(["CLAUDE.md", "AGENTS.md", "GEMINI.md", ".github/copilot-instructions.md"]);

async function checkGitignore(filePath: string): Promise<void> {
  // Only suggest for files in hidden directories (tool-specific)
  if (TRACK_BY_DEFAULT.has(filePath)) return;

  const gitignorePath = resolve(".gitignore");
  try {
    const content = existsSync(gitignorePath)
      ? await readFile(gitignorePath, "utf-8")
      : "";

    // Check if already ignored (exact line match or parent dir match)
    const lines = content.split("\n");
    const parentDir = filePath.split("/")[0]; // e.g. ".cursor"
    if (lines.some((l) => l.trim() === filePath || l.trim() === parentDir || l.trim() === `${parentDir}/`)) {
      return;
    }

    console.log(chalk.dim(`  hint: add "${filePath}" to .gitignore if you don't want it tracked`));
  } catch {
    // Ignore errors reading .gitignore
  }
}

async function writeTarget(
  target: Target,
  memories: Memory[],
  opts: { output?: string; dryRun?: boolean; force?: boolean },
): Promise<void> {
  const outPath = resolve(opts.output ?? target.defaultPath);
  const content = target.format(memories) + makeFooter();

  if (opts.dryRun) {
    console.log(chalk.dim(`── ${target.name} → ${outPath} ──`));
    console.log(content);
    console.log();
    return;
  }

  // Overwrite safety
  if (existsSync(outPath)) {
    const ours = await hasOurMarker(outPath);
    if (!ours && !opts.force) {
      console.error(
        chalk.yellow("⚠") +
          ` ${outPath} exists and was not generated by memories.sh. Use ${chalk.bold("--force")} to overwrite.`,
      );
      return;
    }
  }

  await mkdir(dirname(outPath), { recursive: true });
  await writeFile(outPath, content, "utf-8");
  console.log(chalk.green("✓") + ` Wrote ${target.name} → ${chalk.dim(outPath)}`);

  // Suggest .gitignore for tool-specific hidden dirs
  await checkGitignore(opts.output ?? target.defaultPath);
}

// ── Fetch Memories ──────────────────────────────────────────────────

async function fetchMemories(types: MemoryType[]): Promise<Memory[]> {
  const projectId = getProjectId() ?? undefined;
  return listMemories({
    limit: 10000,
    types,
    projectId,
  });
}

function parseTypes(raw: string | undefined): MemoryType[] {
  if (!raw) return ["rule", "decision", "fact"];
  const types = raw.split(",").map((s) => s.trim()) as MemoryType[];
  for (const t of types) {
    if (!VALID_TYPES.includes(t)) {
      console.error(chalk.red("✗") + ` Invalid type "${t}". Valid: ${VALID_TYPES.join(", ")}`);
      process.exit(1);
    }
  }
  return types;
}

// ── Watch Mode ──────────────────────────────────────────────────────

function getDbPath(): string {
  const dataDir = process.env.MEMORIES_DATA_DIR ?? join(homedir(), ".config", "memories");
  return join(dataDir, "local.db");
}

async function runWatch(
  targets: Target[],
  memories: () => Promise<Memory[]>,
  opts: { force?: boolean },
): Promise<void> {
  const dbPath = getDbPath();
  if (!existsSync(dbPath)) {
    console.error(chalk.red("✗") + " Database not found. Run: memories init");
    process.exit(1);
  }

  console.log(chalk.dim(`Watching ${dbPath} for changes... (Ctrl+C to stop)\n`));

  // Initial generate
  const mems = await memories();
  if (mems.length > 0) {
    for (const target of targets) {
      await writeTarget(target, mems, { force: opts.force ?? true });
    }
  }

  // Watch for DB changes with debounce
  let timeout: ReturnType<typeof setTimeout> | null = null;
  fsWatch(dbPath, () => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(async () => {
      try {
        const mems = await memories();
        if (mems.length > 0) {
          for (const target of targets) {
            await writeTarget(target, mems, { force: true });
          }
        }
      } catch (err) {
        console.error(chalk.red("✗") + " Watch error:", (err as Error).message);
      }
    }, 500);
  });

  // Keep process alive
  await new Promise(() => {});
}

// ── Command ─────────────────────────────────────────────────────────

export const generateCommand = new Command("generate")
  .description("Generate IDE rule/instruction files from memories")
  .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
  .option("--dry-run", "Preview without writing")
  .option("--force", "Overwrite files not generated by memories.sh")
  .option("-w, --watch", "Watch for memory changes and auto-regenerate")
  .action(async (opts: { types?: string; dryRun?: boolean; force?: boolean; watch?: boolean }) => {
    try {
      // Interactive mode: prompt user to pick targets
      if (!process.stdin.isTTY) {
        generateCommand.outputHelp();
        return;
      }

      const selected = await checkbox({
        message: "Select targets to generate",
        choices: TARGETS.map((t) => ({
          name: `${t.name} ${chalk.dim(`→ ${t.defaultPath}`)}`,
          value: t.name,
          checked: true,
        })),
      });

      if (selected.length === 0) {
        console.log(chalk.dim("No targets selected."));
        return;
      }

      const types = parseTypes(opts.types);
      const memories = await fetchMemories(types);

      if (memories.length === 0) {
        console.error(chalk.dim("No memories found. Add some with: memories add --rule \"Your rule\""));
        return;
      }

      const selectedSet = new Set(selected);
      for (const target of TARGETS.filter((t) => selectedSet.has(t.name))) {
        await writeTarget(target, memories, opts);
      }

      if (opts.watch) {
        await runWatch(TARGETS, () => fetchMemories(types), opts);
      }
    } catch (error) {
      if ((error as Error).name === "ExitPromptError") return;
      console.error(chalk.red("✗") + " Failed to generate:", error instanceof Error ? error.message : "Unknown error");
      process.exit(1);
    }
  });

// Register a subcommand for each target
for (const target of TARGETS) {
  generateCommand.addCommand(
    new Command(target.name)
      .description(target.description)
      .option("-o, --output <path>", "Override output path")
      .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
      .option("--dry-run", "Preview without writing")
      .option("--force", "Overwrite files not generated by memories.sh")
      .action(async (opts: { output?: string; types?: string; dryRun?: boolean; force?: boolean }) => {
        try {
          const types = parseTypes(opts.types);
          const memories = await fetchMemories(types);

          if (memories.length === 0) {
            console.error(chalk.dim("No memories found. Add some with: memories add --rule \"Your rule\""));
            return;
          }

          await writeTarget(target, memories, opts);
        } catch (error) {
          console.error(chalk.red("✗") + ` Failed to generate ${target.name}:`, error instanceof Error ? error.message : "Unknown error");
          process.exit(1);
        }
      }),
  );
}

// "all" subcommand
generateCommand.addCommand(
  new Command("all")
    .description("Generate rule files for all supported targets")
    .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
    .option("--dry-run", "Preview without writing")
    .option("--force", "Overwrite files not generated by memories.sh")
    .option("-w, --watch", "Watch for memory changes and auto-regenerate")
    .action(async (opts: { types?: string; dryRun?: boolean; force?: boolean; watch?: boolean }) => {
      try {
        const types = parseTypes(opts.types);

        if (opts.watch) {
          await runWatch(TARGETS, () => fetchMemories(types), opts);
          return;
        }

        const memories = await fetchMemories(types);

        if (memories.length === 0) {
          console.error(chalk.dim("No memories found. Add some with: memories add --rule \"Your rule\""));
          return;
        }

        for (const target of TARGETS) {
          await writeTarget(target, memories, opts);
        }
      } catch (error) {
        console.error(chalk.red("✗") + " Failed to generate:", error instanceof Error ? error.message : "Unknown error");
        process.exit(1);
      }
    }),
);
