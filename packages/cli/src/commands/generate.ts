import { Command } from "commander";
import chalk from "chalk";
import { writeFile, readFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { listMemories, type Memory, type MemoryType } from "../lib/memory.js";
import { getProjectId } from "../lib/git.js";

const MARKER = "Generated by memories.sh";
const VALID_TYPES: MemoryType[] = ["rule", "decision", "fact", "note"];

// ── Formatters ──────────────────────────────────────────────────────

function groupByType(memories: Memory[]): { title: string; memories: Memory[] }[] {
  const groups: Record<string, Memory[]> = {};
  for (const m of memories) {
    const title =
      m.type === "rule" ? "Rules" :
      m.type === "decision" ? "Key Decisions" :
      m.type === "fact" ? "Project Facts" :
      "Notes";
    (groups[title] ??= []).push(m);
  }
  // Stable order: Rules → Key Decisions → Project Facts → Notes
  const order = ["Rules", "Key Decisions", "Project Facts", "Notes"];
  return order
    .filter((t) => groups[t]?.length)
    .map((title) => ({ title, memories: groups[title] }));
}

function formatMemoriesAsMarkdown(memories: Memory[]): string {
  const sections = groupByType(memories);
  if (sections.length === 0) return "";
  return sections
    .map(({ title, memories: mems }) => {
      const items = mems.map((m) => `- ${m.content}`).join("\n");
      return `## ${title}\n\n${items}`;
    })
    .join("\n\n");
}

function formatCursorMdc(memories: Memory[]): string {
  const body = formatMemoriesAsMarkdown(memories);
  const frontmatter = [
    "---",
    "description: Project memories and rules from memories.sh",
    "globs:",
    "alwaysApply: true",
    "---",
  ].join("\n");
  return `${frontmatter}\n\n# Project Memories\n\n${body}`;
}

function formatWindsurf(memories: Memory[]): string {
  const full = formatMemoriesAsMarkdown(memories);
  const LIMIT = 6000;
  if (full.length <= LIMIT) return full;
  // Truncate on a line boundary
  const truncated = full.slice(0, LIMIT);
  const lastNewline = truncated.lastIndexOf("\n");
  return lastNewline > 0
    ? truncated.slice(0, lastNewline) + "\n\n> _Truncated to fit Windsurf 6000 char limit._"
    : truncated;
}

// ── Target Registry ─────────────────────────────────────────────────

interface Target {
  name: string;
  defaultPath: string;
  description: string;
  format: (memories: Memory[]) => string;
}

const TARGETS: Target[] = [
  {
    name: "cursor",
    defaultPath: ".cursor/rules/memories.mdc",
    description: "Cursor rules file (.cursor/rules/memories.mdc)",
    format: formatCursorMdc,
  },
  {
    name: "claude",
    defaultPath: "CLAUDE.md",
    description: "Claude Code instructions (CLAUDE.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "agents",
    defaultPath: "AGENTS.md",
    description: "AGENTS.md for Amp, Codex, Goose, Kilo, Kiro, OpenCode",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "copilot",
    defaultPath: ".github/copilot-instructions.md",
    description: "GitHub Copilot instructions (.github/copilot-instructions.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "windsurf",
    defaultPath: ".windsurf/rules/memories.md",
    description: "Windsurf rules (.windsurf/rules/memories.md)",
    format: formatWindsurf,
  },
  {
    name: "cline",
    defaultPath: ".clinerules/memories.md",
    description: "Cline rules (.clinerules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "roo",
    defaultPath: ".roo/rules/memories.md",
    description: "Roo rules (.roo/rules/memories.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
  {
    name: "gemini",
    defaultPath: "GEMINI.md",
    description: "Gemini instructions (GEMINI.md)",
    format: (m) => `# Project Memories\n\n${formatMemoriesAsMarkdown(m)}`,
  },
];

// ── Shared Write Logic ──────────────────────────────────────────────

function makeFooter(): string {
  return `\n\n<!-- ${MARKER} at ${new Date().toISOString()} -->`;
}

async function hasOurMarker(filePath: string): Promise<boolean> {
  try {
    const content = await readFile(filePath, "utf-8");
    return content.includes(MARKER);
  } catch {
    return false;
  }
}

async function writeTarget(
  target: Target,
  memories: Memory[],
  opts: { output?: string; dryRun?: boolean; force?: boolean },
): Promise<void> {
  const outPath = resolve(opts.output ?? target.defaultPath);
  const content = target.format(memories) + makeFooter();

  if (opts.dryRun) {
    console.log(chalk.dim(`── ${target.name} → ${outPath} ──`));
    console.log(content);
    console.log();
    return;
  }

  // Overwrite safety
  if (existsSync(outPath)) {
    const ours = await hasOurMarker(outPath);
    if (!ours && !opts.force) {
      console.error(
        chalk.yellow("⚠") +
          ` ${outPath} exists and was not generated by memories.sh. Use ${chalk.bold("--force")} to overwrite.`,
      );
      return;
    }
  }

  await mkdir(dirname(outPath), { recursive: true });
  await writeFile(outPath, content, "utf-8");
  console.log(chalk.green("✓") + ` Wrote ${target.name} → ${chalk.dim(outPath)}`);
}

// ── Fetch Memories ──────────────────────────────────────────────────

async function fetchMemories(types: MemoryType[]): Promise<Memory[]> {
  const projectId = getProjectId() ?? undefined;
  return listMemories({
    limit: 10000,
    types,
    projectId,
  });
}

function parseTypes(raw: string | undefined): MemoryType[] {
  if (!raw) return ["rule", "decision", "fact"];
  const types = raw.split(",").map((s) => s.trim()) as MemoryType[];
  for (const t of types) {
    if (!VALID_TYPES.includes(t)) {
      console.error(chalk.red("✗") + ` Invalid type "${t}". Valid: ${VALID_TYPES.join(", ")}`);
      process.exit(1);
    }
  }
  return types;
}

// ── Command ─────────────────────────────────────────────────────────

export const generateCommand = new Command("generate")
  .description("Generate IDE rule/instruction files from memories");

// Register a subcommand for each target
for (const target of TARGETS) {
  generateCommand.addCommand(
    new Command(target.name)
      .description(target.description)
      .option("-o, --output <path>", "Override output path")
      .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
      .option("--dry-run", "Preview without writing")
      .option("--force", "Overwrite files not generated by memories.sh")
      .action(async (opts: { output?: string; types?: string; dryRun?: boolean; force?: boolean }) => {
        try {
          const types = parseTypes(opts.types);
          const memories = await fetchMemories(types);

          if (memories.length === 0) {
            console.error(chalk.dim("No memories found. Add some with: memories add --rule \"Your rule\""));
            return;
          }

          await writeTarget(target, memories, opts);
        } catch (error) {
          console.error(chalk.red("✗") + ` Failed to generate ${target.name}:`, error instanceof Error ? error.message : "Unknown error");
          process.exit(1);
        }
      }),
  );
}

// "all" subcommand
generateCommand.addCommand(
  new Command("all")
    .description("Generate rule files for all supported targets")
    .option("--types <types>", "Comma-separated types to include (default: rule,decision,fact)")
    .option("--dry-run", "Preview without writing")
    .option("--force", "Overwrite files not generated by memories.sh")
    .action(async (opts: { types?: string; dryRun?: boolean; force?: boolean }) => {
      try {
        const types = parseTypes(opts.types);
        const memories = await fetchMemories(types);

        if (memories.length === 0) {
          console.error(chalk.dim("No memories found. Add some with: memories add --rule \"Your rule\""));
          return;
        }

        for (const target of TARGETS) {
          await writeTarget(target, memories, opts);
        }
      } catch (error) {
        console.error(chalk.red("✗") + " Failed to generate:", error instanceof Error ? error.message : "Unknown error");
        process.exit(1);
      }
    }),
);
