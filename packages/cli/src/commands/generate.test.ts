import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdtempSync, writeFileSync, readFileSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { rmSync } from "node:fs";

describe("generate", () => {
  let tmpDir: string;

  beforeEach(() => {
    tmpDir = mkdtempSync(join(tmpdir(), "memories-gen-out-"));
  });

  afterEach(() => {
    rmSync(tmpDir, { recursive: true, force: true });
  });

  describe("overwrite safety", () => {
    const MARKER = "Generated by memories.sh";

    it("should detect marker in generated files", () => {
      const outPath = join(tmpDir, "test.md");
      writeFileSync(outPath, `# Test\n\n<!-- ${MARKER} at 2024-01-01T00:00:00Z -->`);
      const content = readFileSync(outPath, "utf-8");
      expect(content.includes(MARKER)).toBe(true);
    });

    it("should detect absence of marker in manual files", () => {
      const outPath = join(tmpDir, "test.md");
      writeFileSync(outPath, "# My Manual CLAUDE.md\n\nDo not overwrite me.");
      const content = readFileSync(outPath, "utf-8");
      expect(content.includes(MARKER)).toBe(false);
    });
  });

  describe("cursor MDC format", () => {
    it("should produce valid YAML frontmatter", () => {
      const frontmatter = [
        "---",
        "description: Project memories and rules from memories.sh",
        "globs:",
        "alwaysApply: true",
        "---",
      ].join("\n");
      expect(frontmatter.startsWith("---")).toBe(true);
      expect(frontmatter.endsWith("---")).toBe(true);
      expect(frontmatter).toContain("alwaysApply: true");
    });
  });

  describe("windsurf truncation", () => {
    it("should truncate long content at line boundary within 6000 chars", () => {
      const LIMIT = 6000;
      const line = "- This is a memory line that is reasonably long for testing\n";
      const lines = Array(200).fill(line).join("");
      expect(lines.length).toBeGreaterThan(LIMIT);

      const truncated = lines.slice(0, LIMIT);
      const lastNewline = truncated.lastIndexOf("\n");
      const result = lastNewline > 0 ? truncated.slice(0, lastNewline) : truncated;

      expect(result.length).toBeLessThanOrEqual(LIMIT);
      expect(result.endsWith("\n")).toBe(false);
    });

    it("should not truncate content under 6000 chars", () => {
      const content = "- Short memory\n- Another one\n";
      expect(content.length).toBeLessThan(6000);
    });
  });

  describe("type parsing", () => {
    const VALID_TYPES = ["rule", "decision", "fact", "note", "skill"];

    it("should accept valid types", () => {
      for (const t of ["rule", "decision", "fact", "note", "skill"]) {
        expect(VALID_TYPES.includes(t)).toBe(true);
      }
    });

    it("should reject invalid types", () => {
      expect(VALID_TYPES.includes("invalid")).toBe(false);
      expect(VALID_TYPES.includes("")).toBe(false);
    });

    it("should parse comma-separated types", () => {
      const raw = "rule,decision,fact";
      const types = raw.split(",").map((s) => s.trim());
      expect(types).toEqual(["rule", "decision", "fact"]);
    });
  });

  describe("markdown grouping", () => {
    it("should produce sections with ## headers", () => {
      // Simulating formatMemoriesAsMarkdown behavior
      const sections = [
        { title: "Rules", items: ["Always use TypeScript"] },
        { title: "Key Decisions", items: ["Chose Postgres"] },
      ];
      const md = sections
        .map(({ title, items }) => `## ${title}\n\n${items.map((i) => `- ${i}`).join("\n")}`)
        .join("\n\n");

      expect(md).toContain("## Rules");
      expect(md).toContain("## Key Decisions");
      expect(md).toContain("- Always use TypeScript");
      expect(md).toContain("- Chose Postgres");
    });

    it("should maintain stable section order", () => {
      const order = ["Rules", "Key Decisions", "Project Facts", "Notes"];
      expect(order[0]).toBe("Rules");
      expect(order[order.length - 1]).toBe("Notes");
    });
  });
});
