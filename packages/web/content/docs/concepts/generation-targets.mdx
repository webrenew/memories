---
title: Generation Targets
description: How memories.sh generates native config files for each AI tool.
---

The `memories generate` command creates native configuration files that each AI tool understands natively. It uses a two-step pipeline to ensure every tool gets the richest possible configuration.

## Two-Step Pipeline

```
Memory Store → .agents/ (canonical) → Tool-specific configs
```

1. **Generate `.agents/`** — Memories are written to a canonical, tool-agnostic directory structure
2. **Adapt per tool** — The `.agents/` content is translated into each target's native format

This architecture means you have a single source of truth (`.agents/`) that can generate configurations for any number of tools simultaneously.

## The `.agents/` Directory

The canonical intermediate format. Generated by `memories generate agents` (and automatically by other targets):

```
.agents/
├── instructions.md           # Always-on rules, decisions, facts
├── rules/                    # Path-scoped rules with YAML frontmatter
│   ├── api.md
│   └── testing.md
├── skills/                   # Agent Skills standard (SKILL.md)
│   └── deploy/
│       └── SKILL.md
└── settings.json             # Permissions, hooks, env vars
```

### instructions.md

Global context from non-path-scoped memories of type `rule`, `decision`, and `fact`. Equivalent to what goes into `CLAUDE.md`, `AGENTS.md`, or `copilot-instructions.md`.

### rules/*.md

Path-scoped rules. Each file has YAML frontmatter with `paths:` globs:

```markdown
---
paths:
  - "src/api/**"
  - "lib/api/**"
---

- Use RESTful naming conventions
- Return consistent error response format
```

### skills/**/SKILL.md

Follows the [Agent Skills](https://agentskills.io) open standard. Each skill lives in its own category directory with optional supporting files.

### settings.json

Agnostic permission, hook, and env configuration. Modeled on Claude Code's `settings.json` structure, which is the superset most other tools can map from.

## Supported Targets

### `.agents/` (Canonical)

- **Path:** `.agents/`
- **Format:** Structured directory with markdown, YAML frontmatter, and JSON
- The source of truth that all other targets adapt from

### Cursor

- **Path:** `.cursor/rules/`
- **Format:** MDC (Markdown with YAML frontmatter)
- `instructions.md` → `.cursor/rules/memories.mdc` (with `alwaysApply: true`)
- `rules/*.md` → `.cursor/rules/{name}.mdc` (translates `paths:` → `globs:`)
- Skills are copied as-is

### Claude Code

- **Path:** `CLAUDE.md` + `.claude/`
- **Format:** Markdown
- `instructions.md` → `CLAUDE.md`
- `rules/*.md` → `.claude/rules/*.md` (format is native)
- `skills/` → `.claude/skills/` (format is identical)
- `settings.json` → `.claude/settings.json` (permissions merged)

### Agents (Multi-tool)

- **Path:** `AGENTS.md`
- **Format:** Markdown
- Used by Amp, Codex, Goose, Kilo, Kiro, and OpenCode

### GitHub Copilot

- **Path:** `.github/copilot-instructions.md`
- **Format:** Markdown (flat file with inline path annotations)

### Windsurf

- **Path:** `.windsurf/rules/memories.md`
- **Format:** Markdown
- Has a 6000 character limit — content is truncated at line boundaries if exceeded

### Cline

- **Path:** `.clinerules/memories.md`
- **Format:** Markdown

### Roo

- **Path:** `.roo/rules/memories.md`
- **Format:** Markdown

### Gemini

- **Path:** `GEMINI.md`
- **Format:** Markdown

## File Marker

All generated files include a marker comment:

```
<!-- Generated by memories.sh at 2026-01-15T10:30:00Z -->
```

This marker serves two purposes:
1. **Overwrite protection** — `memories generate` won't overwrite files without this marker unless `--force` is used
2. **Ingest detection** — `memories ingest` skips files with this marker to avoid circular imports

## Gitignore Recommendations

After generating files, memories.sh may suggest adding tool-specific directories to `.gitignore`. Whether you commit generated files is up to you:

- **Commit them** if you want the rules visible to collaborators who don't use memories.sh
- **Gitignore them** if all team members use memories.sh and generate locally
